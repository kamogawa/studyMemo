Javascript개발시 문제점 
빌드 과정이 없기 때문에 에러 예측이 어려움
타입이 헷갈림

품질 높은 코드를 만들기 위해 TDD (테스트 주도 개발)로 극복

1. 기능 코드 작성 전에 유닛 테스트를 작성 (적색 단계: 대상이 없기에 테스트는 실패함)
유닛 테스트: 특정 조건에서 어떻게 작동될 것인지 정의 한 것, 대체로 함수로 표현
     준비 -> 실행 -> 단언 assert　패턴을 따름
     
2. 함수의 기능 구현후 테스트가 통과 되게 함(녹색 단계)     

3. 리팩토링 반복 추상화, 확장가능, 중복제거 소프트웨어 공학원칙에 맞는 코드로 변경 (블루 단계)
  기존로직을 변경해야 하기 때문에 개발자에게 부담
  tdd로 개발하면 내가 작성한 리펙토링이 확실하다는 보장을 받음


테스트러너: 테스트코드를 실행하는 것
테스트 스위트: 꾸러미 
테스트 스펙: 기대식을 가진 테스트 구현 함수

기대식과 매쳐
스파이: 감시할 객체, 함수ㄱ

관심사의 분리: 하나의 코드가 여려 역할을 하는 것은 좋지 않음
소프트웨어 공학: 단일책임의 원칙, 읽기 쉽고 명확함

전역변수의 충돌: 
다른 모듈과 충돌하는 등 안티패턴이 발생할 가능성 높음기 때문에 사용을 자제하는 것이 좋음
소프트웨어 공학: 오픈 클로즈의 원칙, 확장에는 열려있고 변경에는 닫혀 있어야 한다.
함수는 쉽게 변경되어서는 안된다. 기능을 추가 할거라면 새로운 함수를 만드는 것이 아니라 기존 함수를 확장해서 만들어라

재사용의 어려움 등등

모듈패턴: 많은 개발자들의 경험에서 나온 패턴을 사용하는 것을 추천.
함수로 데이터를 감추고, 모듈api를 담고 있는 객체를 반환하는 형태
원칙 
1. 단일 책임 원칙에 때라 모듈은 한가지 역할만 한다.
그 역할만 집중함으로 모듈을 더욱 견고하고 테스트가 쉽게 가능하짐. 

2. 모듈은 자신이 사용할 객체가 있다면 의존성 주입 형태로 제공한다. 


ex1) 임의함수를 호출하여 생성하는 모듈

//namespace
var App = App || {}


//namespace에 함수를 추가, 의존성있는 다른 함수를 주입
App.Person ＝ function (God) {
  var name = God.makeName()

  //Api호출
  return {
    getName: function() { return name},
    setName: function(newName) {name = newName}
  }
}

const person = App.Persion(God)
person.getName()
ex2) 즉시실행 함수 기반의 모듈 
생략 ..


 
